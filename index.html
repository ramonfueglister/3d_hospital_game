<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Krankenhausabenteuer</title>
  <!-- Google Fonts hinzufügen -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { margin: 0; overflow: hidden; font-family: 'Roboto', sans-serif; }

    /* Verbesserter Startbildschirm */
    #startScreen {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7); /* Halbtransparenter Hintergrund */
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 10;
      text-align: center;
      padding: 40px;
      color: #ffffff;
      animation: fadeIn 1s ease-in-out;
    }

    /* Titel-Stil */
    #startScreen h1 {
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.5);
    }

    /* Beschreibungs-Stil */
    #startScreen p {
      font-size: 20px;
      margin: 10px 0;
      max-width: 600px;
      line-height: 1.5;
    }

    /* Listen-Stil */
    #startScreen ul {
      list-style: none;
      padding: 0;
      margin: 10px 0;
      text-align: left;
      max-width: 600px;
    }

    #startScreen li {
      margin: 8px 0;
      font-size: 18px;
    }

    /* Button-Stil */
    #startScreen button {
      padding: 15px 30px;
      font-size: 20px;
      margin-top: 30px;
      background-color: #ff4081;
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.3s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    #startScreen button:hover {
      background-color: #f50057;
      transform: scale(1.05);
    }

    /* Fade-In Animation */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* HUD und andere Elemente bleiben unverändert */
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 18px;
      z-index: 5;
    }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 24px;
      border: 2px solid white;
      display: none;
      z-index: 5;
    }
    #question {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px;
      background-color: rgba(255, 255, 255, 0.9);
      color: black;
      font-size: 18px;
      border: 2px solid black;
      max-width: 80%;
      z-index: 5;
    }
    #question button {
      margin-top: 10px;
      display: block;
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    #question button:hover {
      background-color: #e0e0e0;
    }
    #endScreen {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 10;
      color: white;
      font-size: 36px;
      text-align: center;
    }
    #endScreen button {
      padding: 15px 30px;
      font-size: 20px;
      margin-top: 20px;
      background-color: #ff4081;
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.3s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }
    #endScreen button:hover {
      background-color: #f50057;
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <!-- Startbildschirm -->
  <div id="startScreen">
    <h1>Willkommen zum Krankenhausabenteuer</h1>
    <p>Steuerung:</p>
    <ul>
      <li><strong>W</strong> - Vorwärts bewegen</li>
      <li><strong>S</strong> - Rückwärts bewegen</li>
      <li><strong>A</strong> - Nach links bewegen</li>
      <li><strong>D</strong> - Nach rechts bewegen</li>
    </ul>
    <p>Ziel des Spiels:</p>
    <p>Interagieren Sie mit den NPCs und beantworten Sie ihre Fragen. Sammeln Sie 100 Punkte, bevor der Timer abläuft!</p>
    <button onclick="startGame()">Spiel starten</button>
  </div>

  <!-- HUD -->
  <div id="hud">
    Punktzahl: <span id="score">0</span><br>
    Zeit: <span id="timer">600</span>s
  </div>

  <!-- Nachrichtenbereich -->
  <div id="message"></div>

  <!-- Endbildschirm -->
  <div id="endScreen" style="display: none;">
    <h1 id="endMessage"></h1>
    <button onclick="location.reload()">Neu starten</button>
  </div>

  <!-- Three.js Bibliothek -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Globale Variablen für die Sonne und die Lichtquelle
    var scene, camera, renderer, nurse, controls;
    var npcs = [];
    var score = 0;
    var walls = [];
    var doors = [];
    var hospitalObjects = [];
    var gameStarted = false;
    var questionDiv;
    var questionActive = false;
    var transparentWalls = [];
    var roomWalls = [];
    var npcPool = [];
    var currentNPCs = [];
    var rooms = [];
    var answeredQuestions = {};
    var timer = 600; // 600 Sekunden
    var timerInterval;
    var gameEnded = false;
    var waypoints = []; // Wegpunkte für die NPC-Bewegung

    // Neue globale Variablen für die Sonne
    var sun;
    var directionalLight;
    var gameStartTime;
    var sunRadius = 50; // Radius der Sonnenbahn

    // Variable zum Speichern der geladenen Fragen
    var loadedQuestions = {
      doctor: [],
      nurse: [],
      patient: []
    };

    // Funktion zum Laden der Fragen aus der JSON-Datei auf GitHub
    async function loadQuestions() {
      try {
        const response = await fetch('https://raw.githubusercontent.com/ramonfueglister/3d_hospital_game/main/questions.json');
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        const data = await response.json();

        // Überprüfen Sie den Inhalt der geladenen Daten
        console.log('Fragen erfolgreich geladen:', data);

        // Überprüfen Sie, ob die Daten im erwarteten Format vorliegen
        if (data.doctor && data.nurse && data.patient) {
          loadedQuestions = data;
        } else {
          console.error('Fehler: Die JSON-Daten haben nicht das erwartete Format.');
        }
      } catch (error) {
        console.error('Fehler beim Laden der Fragen:', error);
      }
    }

    async function startGame() {
      await loadQuestions(); // Fragen laden, bevor das Spiel startet

      // Überprüfen Sie, ob die Fragen erfolgreich geladen wurden
      console.log('Geladene Fragen:', loadedQuestions);

      if (!loadedQuestions.doctor.length || !loadedQuestions.nurse.length || !loadedQuestions.patient.length) {
        console.error('Fehler: Keine Fragen wurden geladen. Überprüfen Sie die JSON-Datei und den URL-Pfad.');
        alert('Fehler beim Laden der Fragen. Bitte überprüfen Sie die Entwicklerkonsole für weitere Details.');
        return; // Beenden Sie das Spiel, wenn keine Fragen geladen wurden
      }

      document.getElementById('startScreen').style.display = 'none';
      gameStartTime = Date.now(); // Spielstartzeit festlegen
      init();
      animate();
      startTimer();
    }

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(
        75, window.innerWidth / window.innerHeight, 0.1, 1000
      );

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Beleuchtung
      var ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(0, 50, 50); // Anfangsposition
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      // Himmel hinzufügen
      createSky();

      // Erde als Boden hinzufügen (statt der grünen Plane)
      var earthRadius = 100;
      var earthMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22, side: THREE.FrontSide });
      var earthGeometry = new THREE.SphereGeometry(earthRadius, 32, 32);
      var earth = new THREE.Mesh(earthGeometry, earthMaterial);
      earth.position.set(0, earthRadius, 0); // So dass die untere Hälfte der Kugel auf y=0 liegt
      scene.add(earth);

      // Krankenhaus erstellen
      createHospital();

      // Wegpunkte erstellen
      createWaypoints();

      // Spielerfigur verbessern
      createPlayer();

      // NPCs erstellen
      createNPCPool();
      selectRandomNPCs();

      // Kameraposition
      camera.position.set(0, 15, 30);
      camera.lookAt(nurse.position);

      // Steuerung
      controls = {
        moveForward: false,
        moveBackward: false,
        moveLeft: false,
        moveRight: false
      };

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);

      gameStarted = true;
    }

    function createSky() {
      var skyGeometry = new THREE.SphereGeometry(500, 32, 32);
      var skyMaterial = new THREE.MeshBasicMaterial({
        color: 0x87CEEB, // Himmelblau
        side: THREE.BackSide
      });
      var sky = new THREE.Mesh(skyGeometry, skyMaterial);
      scene.add(sky);

      // Sonne hinzufügen
      var sunGeometry = new THREE.SphereGeometry(5, 32, 32);
      var sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      sun = new THREE.Mesh(sunGeometry, sunMaterial);
      sun.position.set(0, -sunRadius, 50); // Anfangsposition (unter dem Horizont)
      scene.add(sun);
    }

    function startTimer() {
      var timerElement = document.getElementById('timer');
      timerInterval = setInterval(function() {
        if (gameEnded) {
          clearInterval(timerInterval);
          return;
        }
        timer--;
        timerElement.innerText = timer;
        if (timer <= 0) {
          timer = 0;
          timerElement.innerText = timer;
          endGame(false);
        }
      }, 1000);
    }

    function createHospital() {
      var roomConfigs = [
        { x: -30, z: -30, width: 20, depth: 30, name: 'Notaufnahme', color: 0xffcccc },
        { x: 0, z: -30, width: 30, depth: 30, name: 'Wartezimmer', color: 0xccffcc },
        { x: 35, z: -30, width: 30, depth: 30, name: 'Radiologie', color: 0xccccff },
        { x: -30, z: 10, width: 30, depth: 30, name: 'Intensivstation', color: 0xffffcc },
        { x: 10, z: 10, width: 40, depth: 30, name: 'Allgemeine Station', color: 0xffccff },
        { x: 40, z: 10, width: 20, depth: 30, name: 'Operationssaal', color: 0xccffff },
        { x: -30, z: 50, width: 20, depth: 30, name: 'Apotheke', color: 0xffe4b5 },
        { x: 0, z: 50, width: 30, depth: 30, name: 'Labor', color: 0xd3d3d3 },
        { x: 35, z: 50, width: 30, depth: 30, name: 'Personalraum', color: 0xadd8e6 }
      ];

      roomConfigs.forEach(function(config) {
        createRoom(config);
      });

      // Wände für Kollisionserkennung sammeln
      walls = walls.concat(roomWalls);
    }

    function createRoom(config) {
      var wallThickness = 0.5;
      var wallHeight = 5;
      var wallsInRoom = [];

      var halfWidth = config.width / 2;
      var halfDepth = config.depth / 2;

      // Wandmaterial pro Raum
      var wallMaterial = new THREE.MeshLambertMaterial({ color: config.color });

      // Linke Wand
      var leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, config.depth), wallMaterial);
      leftWall.position.set(config.x - halfWidth, wallHeight / 2, config.z);
      scene.add(leftWall);
      wallsInRoom.push(leftWall);

      // Rechte Wand
      var rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, config.depth), wallMaterial);
      rightWall.position.set(config.x + halfWidth, wallHeight / 2, config.z);
      scene.add(rightWall);
      wallsInRoom.push(rightWall);

      // Hintere Wand
      var backWall = new THREE.Mesh(new THREE.BoxGeometry(config.width, wallHeight, wallThickness), wallMaterial);
      backWall.position.set(config.x, wallHeight / 2, config.z - halfDepth);
      scene.add(backWall);
      wallsInRoom.push(backWall);

      // Vordere Wand mit Tür
      var doorWidth = 4;
      var wall1Width = (config.width - doorWidth) / 2;

      var wall1 = new THREE.Mesh(new THREE.BoxGeometry(wall1Width, wallHeight, wallThickness), wallMaterial);
      wall1.position.set(config.x - wall1Width / 2 - doorWidth / 2, wallHeight / 2, config.z + halfDepth);
      scene.add(wall1);
      wallsInRoom.push(wall1);

      var wall2 = new THREE.Mesh(new THREE.BoxGeometry(wall1Width, wallHeight, wallThickness), wallMaterial);
      wall2.position.set(config.x + wall1Width / 2 + doorWidth / 2, wallHeight / 2, config.z + halfDepth);
      scene.add(wall2);
      wallsInRoom.push(wall2);

      // Tür
      var door = new THREE.Mesh(new THREE.BoxGeometry(doorWidth, wallHeight, 0.2), new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
      door.position.set(config.x, wallHeight / 2, config.z + halfDepth + 0.1);
      door.name = config.name;
      door.open = false;
      scene.add(door);
      doors.push(door);
      wallsInRoom.push(door); // Tür zur Kollisionserkennung hinzufügen

      // Türposition speichern
      var doorPosition = new THREE.Vector3(config.x, 1, config.z + halfDepth);

      // Türbeschriftung
      var loader = new THREE.FontLoader();
      loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
        var textGeometry = new THREE.TextGeometry(config.name, {
          font: font,
          size: 0.7,
          height: 0.1
        });
        var textMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
        var textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textMesh.position.set(config.x - config.name.length * 0.35, wallHeight - 1, config.z + halfDepth + 0.5);
        scene.add(textMesh);
      });

      // Raumgrenzen speichern
      var room = {
        name: config.name,
        minX: config.x - halfWidth,
        maxX: config.x + halfWidth,
        minZ: config.z - halfDepth,
        maxZ: config.z + halfDepth,
        doorPosition: doorPosition
      };
      rooms.push(room);

      // Wände für Kollisionserkennung sammeln
      wallsInRoom.forEach(function(wall) {
        roomWalls.push(wall);
      });

      // Möbel hinzufügen
      addFurnitureToRoom(room);
    }

    function addFurnitureToRoom(room) {
      // Pflanzen hinzufügen
      var plantGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
      var plantMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      var plant = new THREE.Mesh(plantGeometry, plantMaterial);
      plant.position.set(room.minX + 2, 1, room.minZ + 2);
      scene.add(plant);
      walls.push(plant); // Für Kollisionserkennung

      // Tisch hinzufügen
      var tableGeometry = new THREE.BoxGeometry(3, 0.5, 2);
      var tableMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      var table = new THREE.Mesh(tableGeometry, tableMaterial);
      table.position.set(room.maxX - 3, 0.25, room.maxZ - 3);
      scene.add(table);
      walls.push(table);

      // Stuhl hinzufügen
      var chairGeometry = new THREE.BoxGeometry(1, 1, 1);
      var chairMaterial = new THREE.MeshLambertMaterial({ color: 0xA0522D });
      var chair = new THREE.Mesh(chairGeometry, chairMaterial);
      chair.position.set(room.maxX - 5, 0.5, room.maxZ - 3);
      scene.add(chair);
      walls.push(chair);

      // Bett hinzufügen
      var bedGeometry = new THREE.BoxGeometry(2, 0.5, 4);
      var bedMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      var bed = new THREE.Mesh(bedGeometry, bedMaterial);
      bed.position.set(room.minX + 3, 0.25, room.maxZ - 3);
      scene.add(bed);
      walls.push(bed);
    }

    function createWaypoints() {
      // Begehbare Bereiche (Flure und offene Bereiche)
      waypoints = [
        // Flur vor den Räumen in der ersten Reihe
        new THREE.Vector3(-30, 1, -15),
        new THREE.Vector3(0, 1, -15),
        new THREE.Vector3(35, 1, -15),
        // Flur vor den Räumen in der zweiten Reihe
        new THREE.Vector3(-30, 1, 25),
        new THREE.Vector3(10, 1, 25),
        new THREE.Vector3(40, 1, 25),
        // Flur vor den Räumen in der dritten Reihe
        new THREE.Vector3(-30, 1, 65),
        new THREE.Vector3(0, 1, 65),
        new THREE.Vector3(35, 1, 65),
        // Kreuzungen
        new THREE.Vector3(-30, 1, 0),
        new THREE.Vector3(0, 1, 0),
        new THREE.Vector3(35, 1, 0),
        new THREE.Vector3(-30, 1, 40),
        new THREE.Vector3(0, 1, 40),
        new THREE.Vector3(35, 1, 40)
      ];
    }

    function createPlayer() {
      // Spielerfigur verbessern
      nurse = new THREE.Group();

      // Körper
      var bodyGeometry = new THREE.BoxGeometry(1, 2, 1);
      var bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
      var body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 1;
      nurse.add(body);

      // Kopf
      var headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      var headMaterial = new THREE.MeshLambertMaterial({ color: 0xffe0bd });
      var head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 2.75;
      nurse.add(head);

      // Arme
      var armGeometry = new THREE.BoxGeometry(0.3, 1, 0.3);
      var armMaterial = new THREE.MeshLambertMaterial({ color: 0xffe0bd });

      var leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-0.65, 1.5, 0);
      nurse.add(leftArm);
      nurse.leftArm = leftArm;

      var rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(0.65, 1.5, 0);
      nurse.add(rightArm);
      nurse.rightArm = rightArm;

      // Beine
      var legGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
      var legMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });

      var leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-0.25, 0.5, 0);
      nurse.add(leftLeg);

      var rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(0.25, 0.5, 0);
      nurse.add(rightLeg);

      nurse.position.set(0, 0, 0);
      scene.add(nurse);
    }

    function createNPCPool() {
      // 50 NPCs mit detaillierten Geschichten generieren
      for (var i = 0; i < 50; i++) {
        var npcType = ['doctor', 'nurse', 'patient'][Math.floor(Math.random() * 3)];
        var npc = generateNPCData(npcType, i);
        npcPool.push(npc);
      }
    }

    function selectRandomNPCs() {
      // 10 zufällige NPCs auswählen
      currentNPCs = npcPool.sort(() => 0.5 - Math.random()).slice(0, 10);
      currentNPCs.forEach(function(data, index) {
        data.idNumber = index;
        createNPC(data.type, data);
      });
    }

    function generateNPCData(type, index) {
      var data = { idNumber: index, type: type };
      data.questions = [];

      data.name = '';
      data.story = '';

      switch (type) {
        case 'doctor':
          data.name = 'Dr. ' + ['Müller', 'Schmidt', 'Klein', 'Fischer', 'Weber'][index % 5];
          data.story = `Ich bin ${data.name}, ein Spezialist für ${['Kardiologie', 'Neurologie', 'Onkologie', 'Orthopädie', 'Dermatologie'][index % 5]}.`;
          break;
        case 'nurse':
          data.name = 'Pflegefachfrau ' + ['Diana', 'Bleona', 'Maria', 'Alina', 'Sophie'][index % 5];
          data.story = `Hallo, ich bin ${data.name}. Ich arbeite auf der Station für ${['Innere Medizin', 'Chirurgie', 'Pädiatrie', 'Gynäkologie', 'Psychiatrie'][index % 5]}.`;
          break;
        case 'patient':
          data.name = ['Thomas', 'Michael', 'Stefan', 'Andreas', 'Markus'][index % 5];
          data.story = `Hallo, ich bin ${data.name}. Ich bin Patient hier im Krankenhaus.`;
          break;
      }

      // Die Fragen werden nun aus der geladenen JSON-Datei genommen
      // Es wird angenommen, dass loadedQuestions bereits geladen wurde
      if (loadedQuestions[type] && loadedQuestions[type].length > 0) {
        // Shuffle the questions to ensure randomness
        var shuffled = loadedQuestions[type].sort(() => 0.5 - Math.random());
        // Nehmen Sie die ersten 10 Fragen oder weniger, je nach Verfügbarkeit
        data.questions = shuffled.slice(0, 10);
      }

      return data;
    }

    function createNPC(type, data) {
      var npc = new THREE.Group();

      // Körper
      var bodyGeometry = new THREE.BoxGeometry(1, 2, 1);
      var bodyMaterial;
      var symbol;
      switch(type) {
        case 'doctor':
          bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
          symbol = '⚕';
          break;
        case 'nurse':
          bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
          symbol = '⛑';
          break;
        case 'patient':
          bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
          symbol = '☺';
          break;
        default:
          bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
          symbol = '?';
      }
      var body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 1;
      npc.add(body);

      // Kopf
      var headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
      var headMaterial = new THREE.MeshLambertMaterial({ color: 0xffe0bd });
      var head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 2.75;
      npc.add(head);

      // Arme
      var armGeometry = new THREE.BoxGeometry(0.3, 1, 0.3);
      var armMaterial = new THREE.MeshLambertMaterial({ color: 0xffe0bd });

      var leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-0.65, 1.5, 0);
      npc.add(leftArm);
      npc.leftArm = leftArm;

      var rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(0.65, 1.5, 0);
      npc.add(rightArm);
      npc.rightArm = rightArm;

      // Beine
      var legGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
      var legMaterial = bodyMaterial;

      var leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-0.25, 0.5, 0);
      npc.add(leftLeg);

      var rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(0.25, 0.5, 0);
      npc.add(rightLeg);

      // NPC an zufälligem Wegpunkt platzieren
      var startWaypoint = waypoints[Math.floor(Math.random() * waypoints.length)];
      npc.position.copy(startWaypoint);

      npc.name = data.name;
      npc.story = data.story;
      npc.questions = data.questions;
      npc.idNumber = data.idNumber;
      npc.type = type;
      npc.targetPosition = null;
      npc.isPaused = false; // NPC ist standardmäßig nicht pausiert
      npc.questionsAsked = 0; // Anzahl der gestellten Fragen

      // Symbol über dem Kopf hinzufügen
      var spriteMaterial = new THREE.SpriteMaterial({
        map: new THREE.CanvasTexture(generateTextCanvas(symbol, 64)),
        depthTest: false
      });
      var sprite = new THREE.Sprite(spriteMaterial);
      sprite.position.set(0, 3.5, 0);
      sprite.scale.set(1.5, 1.5, 1);
      npc.add(sprite);

      scene.add(npc);
      npcs.push(npc);
    }

    function generateTextCanvas(text, size) {
      var canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      var context = canvas.getContext('2d');
      context.font = size + 'px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, size / 2, size / 2);
      return canvas;
    }

    function onKeyDown(event) {
      if (gameEnded) return;
      switch (event.keyCode) {
        case 87: // W
          controls.moveForward = true;
          break;
        case 83: // S
          controls.moveBackward = true;
          break;
        case 65: // A
          controls.moveLeft = true;
          break;
        case 68: // D
          controls.moveRight = true;
          break;
      }
    }

    function onKeyUp(event) {
      switch (event.keyCode) {
        case 87: // W
          controls.moveForward = false;
          break;
        case 83: // S
          controls.moveBackward = false;
          break;
        case 65: // A
          controls.moveLeft = false;
          break;
        case 68: // D
          controls.moveRight = false;
          break;
      }
    }

    function animate() {
      if (!gameStarted || gameEnded) return;

      requestAnimationFrame(animate);

      // Bewegung der Krankenschwester
      var speed = 0.3;
      var deltaX = 0;
      var deltaZ = 0;
      if (controls.moveForward) deltaZ -= speed;
      if (controls.moveBackward) deltaZ += speed;
      if (controls.moveLeft) deltaX -= speed;
      if (controls.moveRight) deltaX += speed;

      nurse.position.x += deltaX;
      nurse.position.z += deltaZ;

      // Kollisionserkennung für Spieler
      checkCollisions(nurse, deltaX, deltaZ);

      // Arme der Spielfigur bewegen
      animateArms(nurse, deltaX !== 0 || deltaZ !== 0);

      // Türen öffnen/schließen und Kollision aktualisieren
      updateDoors();

      // Kamera folgen
      camera.position.x = nurse.position.x;
      camera.position.z = nurse.position.z + 30;
      camera.position.y = nurse.position.y + 15;
      camera.lookAt(nurse.position.x, nurse.position.y + 2, nurse.position.z);

      // Wände transparent machen, wenn sie die Sicht blockieren
      updateTransparentWalls();

      // NPC-Bewegung
      npcs.forEach(function(npc) {
        if (npc.isPaused) {
          return; // NPC ist pausiert und bewegt sich nicht
        }

        // Wenn NPC kein Ziel hat, neues Ziel zuweisen
        if (!npc.targetPosition) {
          assignNPCTargetPosition(npc);
        }

        // Richtung zum Ziel berechnen
        var direction = new THREE.Vector3().subVectors(npc.targetPosition, npc.position);
        var distance = direction.length();

        if (distance > 0.1) {
          direction.normalize();
          var npcSpeed = 0.05;
          var deltaX_npc = direction.x * npcSpeed;
          var deltaZ_npc = direction.z * npcSpeed;

          npc.position.x += deltaX_npc;
          npc.position.z += deltaZ_npc;

          // Arme des NPCs bewegen
          animateArms(npc, true);

          // Kollisionserkennung für NPCs
          if (checkCollisions(npc, deltaX_npc, deltaZ_npc)) {
            // Bei Kollision neues Ziel zuweisen
            assignNPCTargetPosition(npc);
          }
        } else {
          // Ziel erreicht, neues Ziel zuweisen
          assignNPCTargetPosition(npc);

          // Arme des NPCs stoppen
          animateArms(npc, false);
        }
      });

      // Interaktion mit NPCs
      npcs.forEach(function(npc) {
        var distanceToNurse = nurse.position.distanceTo(npc.position);
        if (distanceToNurse < 3) {
          if (!questionActive) {
            showQuestion(npc);
          }
        } else if (questionActive && currentNPC && currentNPC.idNumber === npc.idNumber && distanceToNurse >= 3) {
          hideQuestion();
        }
      });

      // Sonnenbewegung aktualisieren
      updateSunPosition();

      renderer.render(scene, camera);
    }

    function animateArms(object, isMoving) {
      if (isMoving) {
        var time = Date.now() * 0.005;
        var armSwing = Math.sin(time) * 0.5;

        if (object.leftArm) {
          object.leftArm.rotation.x = armSwing;
        }
        if (object.rightArm) {
          object.rightArm.rotation.x = -armSwing;
        }
      } else {
        if (object.leftArm) {
          object.leftArm.rotation.x = 0;
        }
        if (object.rightArm) {
          object.rightArm.rotation.x = 0;
        }
      }
    }

    function checkCollisions(object, deltaX, deltaZ) {
      var collision = false;
      var objectBox = new THREE.Box3().setFromObject(object);
      walls.forEach(function(wall) {
        var wallBox = new THREE.Box3().setFromObject(wall);
        if (objectBox.intersectsBox(wallBox)) {
          object.position.x -= deltaX;
          object.position.z -= deltaZ;
          collision = true;
        }
      });
      return collision;
    }

    function updateDoors() {
      doors.forEach(function(door) {
        var nurseDistance = nurse.position.distanceTo(door.position);
        var npcNear = npcs.some(function(npc) {
          return npc.position.distanceTo(door.position) < 5;
        });

        if ((nurseDistance < 5 || npcNear) && !door.open) {
          door.open = true;
          // Tür aus Szene und Kollisionserkennung entfernen
          scene.remove(door);
          var index = walls.indexOf(door);
          if (index > -1) walls.splice(index, 1);
        } else if ((nurseDistance >= 5 && !npcNear) && door.open) {
          door.open = false;
          // Tür wieder zur Szene und Kollisionserkennung hinzufügen
          scene.add(door);
          walls.push(door);
        }
      });
    }

    function updateTransparentWalls() {
      transparentWalls.forEach(function(wall) {
        wall.material.opacity = 1;
        wall.material.transparent = false;
      });
      transparentWalls = [];

      var directionVector = nurse.position.clone().sub(camera.position).normalize();
      var raycaster = new THREE.Raycaster(camera.position, directionVector);
      var intersects = raycaster.intersectObjects(walls);

      intersects.forEach(function(intersect) {
        var wall = intersect.object;
        wall.material.opacity = 0.5;
        wall.material.transparent = true;
        transparentWalls.push(wall);
      });
    }

    function assignNPCTargetPosition(npc) {
      npc.targetPosition = waypoints[Math.floor(Math.random() * waypoints.length)].clone();
    }

    var currentNPC;

    function showQuestion(npc) {
      questionActive = true;
      currentNPC = npc;
      npc.isPaused = true; // NPC anhalten

      // Überprüfen, ob der NPC noch Fragen hat
      if (npc.questionsAsked >= 3) {
        showMessage(npc.name + ': "Vielen Dank für Ihre Hilfe!"');
        npc.isPaused = false;
        questionActive = false;
        currentNPC = null;
        return;
      }

      // Finde eine zufällige unbeantwortete Frage
      var npcKey = 'npc_' + npc.idNumber;
      if (!answeredQuestions[npcKey]) {
        answeredQuestions[npcKey] = [];
      }

      var remainingQuestions = npc.questions.filter((q, index) => !answeredQuestions[npcKey].includes(index));

      if (remainingQuestions.length === 0) {
        showMessage(npc.name + ': "Vielen Dank für Ihre Hilfe!"');
        npc.isPaused = false;
        questionActive = false;
        currentNPC = null;
        return;
      }

      var randomIndex = Math.floor(Math.random() * remainingQuestions.length);
      var questionData = remainingQuestions[randomIndex];
      var questionIndex = npc.questions.indexOf(questionData);

      questionDiv = document.createElement('div');
      questionDiv.id = 'question';
      questionDiv.innerHTML = `
        <p>${npc.story}</p>
        <p>${npc.name} fragt: ${questionData.question}</p>
        <button onclick="selectAnswer(1, ${npc.idNumber}, ${questionIndex})">${questionData.answers[0]}</button>
        <button onclick="selectAnswer(2, ${npc.idNumber}, ${questionIndex})">${questionData.answers[1]}</button>
        <button onclick="selectAnswer(3, ${npc.idNumber}, ${questionIndex})">${questionData.answers[2]}</button>
      `;
      document.body.appendChild(questionDiv);
    }

    function hideQuestion() {
      questionActive = false;
      if (questionDiv) {
        document.body.removeChild(questionDiv);
        questionDiv = null;
      }
      if (currentNPC) {
        currentNPC.isPaused = false; // NPC Bewegung fortsetzen
        currentNPC = null;
      }
    }

    function showMessage(text) {
      var messageDiv = document.getElementById('message');
      messageDiv.innerText = text;
      messageDiv.style.display = 'block';
      setTimeout(function() {
        messageDiv.style.display = 'none';
      }, 2000);
    }

    function selectAnswer(choice, npcId, questionIndex) {
      var npc = npcs.find(n => n.idNumber === npcId);
      var questionData = npc.questions[questionIndex];
      var message;
      if (choice === questionData.correctAnswer) {
        message = "Antwort ist richtig.";
        score += 10;
      } else {
        message = "Antwort ist leider falsch.";
        // Nur bei richtiger Antwort Punkte erhalten, keine Abzüge
      }
      showMessage(message);
      document.getElementById('score').innerText = score;

      // Frage als beantwortet markieren
      var npcKey = 'npc_' + npcId;
      if (!answeredQuestions[npcKey]) {
        answeredQuestions[npcKey] = [];
      }
      answeredQuestions[npcKey].push(questionIndex);
      npc.questionsAsked++;

      hideQuestion();

      // Überprüfen, ob der Spieler gewonnen hat
      if (score >= 100) {
        endGame(true);
      }
    }

    function endGame(won) {
      gameEnded = true;
      clearInterval(timerInterval);
      var endScreen = document.getElementById('endScreen');
      var endMessage = document.getElementById('endMessage');
      if (won) {
        endMessage.innerText = 'Sie haben gewonnen! Ihre Punktzahl: ' + score;
      } else {
        endMessage.innerText = 'Zeit abgelaufen! Game Over. Ihre Punktzahl: ' + score;
      }
      endScreen.style.display = 'flex';
    }

    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Funktion zur Aktualisierung der Sonnenposition
    function updateSunPosition() {
      if (!gameStartTime) return;

      var elapsedTime = (Date.now() - gameStartTime) / 1000; // in Sekunden
      var totalGameTime = 600; // Gesamtspielzeit in Sekunden
      var t = elapsedTime / totalGameTime;

      if (t > 1) t = 1; // Begrenzen auf t=1

      // Berechne den Winkel der Sonne (von -90° bis +270°)
      var angle = -Math.PI / 2 + t * 2 * Math.PI;

      // Berechne die neue Position der Sonne
      var x = sunRadius * Math.cos(angle);
      var y = sunRadius * Math.sin(angle);
      var z = 50; // Sonne bleibt in der Front der Szene

      sun.position.set(x, y, z);

      // Aktualisiere die Position des Lichts entsprechend der Sonne
      directionalLight.position.set(x, y, z);
      directionalLight.lookAt(0, 0, 0); // Licht auf die Szene ausrichten

      // Ändere die Intensität des Lichts basierend auf der Sonnenhöhe
      directionalLight.intensity = Math.max(0.2, y / sunRadius);

      // Optional: Ändere die Farbe des Himmels basierend auf der Sonnenhöhe
      var skyColor = new THREE.Color(0x87CEEB); // Standard Himmelblau
      if (y < 0) {
        skyColor = new THREE.Color(0x000033); // Nachtblau
      } else if (y < sunRadius * 0.5) {
        skyColor = new THREE.Color(0x87CEEB); // Himmelblau
      } else {
        skyColor = new THREE.Color(0xFFD700); // Gold
      }
      scene.background = skyColor;
    }
  </script>
</body>
</html>
