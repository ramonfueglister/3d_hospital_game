<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Patient 0</title>
  <!-- Google Fonts hinzufügen -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body { margin: 0; overflow: hidden; font-family: 'Roboto', sans-serif; }

    /* Verbesserter Startbildschirm */
    #startScreen {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7); /* Halbtransparenter Hintergrund */
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 10;
      text-align: center;
      padding: 40px;
      color: #ffffff;
      animation: fadeIn 1s ease-in-out;
    }

    /* Titel-Stil */
    #startScreen h1 {
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.5);
    }

    /* Beschreibungs-Stil */
    #startScreen p {
      font-size: 20px;
      margin: 10px 0;
      max-width: 600px;
      line-height: 1.5;
    }

    /* Listen-Stil */
    #startScreen ul {
      list-style: none;
      padding: 0;
      margin: 10px 0;
      text-align: left;
      max-width: 600px;
    }

    #startScreen li {
      margin: 8px 0;
      font-size: 18px;
    }

    /* Button-Stil */
    #startScreen button {
      padding: 15px 30px;
      font-size: 20px;
      margin-top: 30px;
      background-color: #ff4081;
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.3s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    #startScreen button:hover {
      background-color: #f50057;
      transform: scale(1.05);
    }

    /* Fade-In Animation */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    /* HUD und andere Elemente */
    #hud {
      position: absolute;
      top: 10px;
      right: 10px; /* Highscore rechts oben */
      color: white;
      font-size: 18px;
      z-index: 5;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
      text-align: right;
    }

    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 15px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 24px;
      border: 2px solid white;
      display: none;
      z-index: 5;
    }

    #question {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px;
      background-color: rgba(255, 255, 255, 0.9);
      color: black;
      font-size: 18px;
      border: 2px solid black;
      max-width: 80%;
      z-index: 5;
    }

    #question button {
      margin-top: 10px;
      display: block;
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    #question button:hover {
      background-color: #e0e0e0;
    }

    #endScreen {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 10;
      color: white;
      font-size: 36px;
      text-align: center;
    }

    #endScreen button {
      padding: 15px 30px;
      font-size: 20px;
      margin-top: 20px;
      background-color: #ff4081;
      border: none;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.3s;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    #endScreen button:hover {
      background-color: #f50057;
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <!-- Startbildschirm -->
  <div id="startScreen">
    <h1>Willkommen zu Patient 0</h1>
    <p>Steuere deinen Charakter durch das Krankenhaus, beantworte Fragen und heile so viele Patienten wie möglich!</p>
    <h2>Steuerung:</h2>
    <ul>
      <li><strong>W</strong> - Vorwärts bewegen</li>
      <li><strong>S</strong> - Rückwärts bewegen</li>
      <li><strong>A</strong> - Nach links bewegen</li>
      <li><strong>D</strong> - Nach rechts bewegen</li>
    </ul>
    <h2>Spielziel:</h2>
    <p>Als Krankenpfleger ist es deine Aufgabe, Patienten zu heilen und dabei wichtige Fragen zu beantworten. 
       Jede richtig beantwortete Frage erhöht deine Pflegepunkte. 
       Aber sei vorsichtig: Jeder geheilte Patient zieht Pflegepunkte ab! 
       Behalte deine Pflegepunkte im Auge und versuche, einen möglichst hohen Highscore zu erreichen.</p>
    <button onclick="startGame()">Spiel starten</button>
    <!-- Autor und Jahreszahl -->
    <p style="margin-top: 20px; font-size: 16px; color: #ffffff;">Ein Spiel von Ramon Füglister, 2024</p>
  </div>

  <!-- HUD -->
  <div id="hud">
    Pflegepunkte: <span id="carePoints">100</span><br>
    Highscore: <span id="highscore">0</span><br>
    Zeit: <span id="timer">600</span>s
  </div>

  <!-- Nachrichtenbereich -->
  <div id="message"></div>

  <!-- Endbildschirm -->
  <div id="endScreen" style="display: none;">
    <h1 id="endMessage"></h1>
    <button onclick="location.reload()">Neu starten</button>
  </div>

  <!-- Three.js Bibliothek -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Globale Variablen
    var scene, camera, renderer, nurse, controls;
    var npcs = [];
    var walls = [];
    var doors = [];
    var hospitalObjects = [];
    var gameStarted = false;
    var questionDiv;
    var questionActive = false;
    var transparentWalls = [];
    var roomWalls = [];
    var npcPool = [];
    var currentNPCs = [];
    var rooms = [];
    var answeredQuestions = {};
    var timer = 600; // 600 Sekunden
    var timerInterval;
    var gameEnded = false;
    var waypoints = []; // Wegpunkte für die NPC-Bewegung

    // Neue Variablen für Patientenmanagement
    var patients = [];
    var nextPatientSpawnTime = 0; // Nächste Spawn-Zeit
    var patientSpawnInterval = 10000; // 10 Sekunden in Millisekunden
    var spawnIntervalId;
    var questionCheckIntervalId;

    // Variable zum Speichern der geladenen Fragen
    var loadedQuestions = {
      doctor: [],
      nurse: [],
      patient: []
    };

    // Neue Variablen für das Punktesystem
    var carePoints = 100; // Startpflegepunkte
    var highscore = 0; // Highscore

    // Variablen für Fragenüberprüfung pro Minute
    var questionsAnsweredInLastMinute = 0;
    var questionCheckInterval = 60000; // 1 Minute in Millisekunden

    // Funktion zum Laden der Fragen aus der JSON-Datei auf GitHub
    async function loadQuestions() {
      try {
        const response = await fetch('https://raw.githubusercontent.com/ramonfueglister/3d_hospital_game/main/questions.json');
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        // Debugging: Überprüfen, ob die Antwort korrekt ist
        console.log('Antwort erfolgreich empfangen:', response);
        
        const data = await response.json();

        // Überprüfen Sie den Inhalt der geladenen Daten
        console.log('Fragen erfolgreich geladen:', data);

        // Überprüfen Sie, ob die Daten im erwarteten Format vorliegen
        if (data.doctor && data.nurse && data.patient) {
          if (data.doctor.length === 0 || data.nurse.length === 0) {
            console.error('Fehler: Keine Fragen für Ärzte oder Pflegekräfte vorhanden.');
          } else {
            loadedQuestions = data;
            console.log('Fragen erfolgreich zugewiesen:', loadedQuestions);
          }
        } else {
          console.error('Fehler: Die JSON-Daten haben nicht das erwartete Format.');
          console.log('Geladene Daten:', data);
        }
      } catch (error) {
        console.error('Fehler beim Laden der Fragen:', error);
      }
    }

    async function startGame() {
      await loadQuestions(); // Fragen laden, bevor das Spiel startet

      // Überprüfen Sie, ob die Fragen erfolgreich geladen wurden
      console.log('Geladene Fragen:', loadedQuestions);

      if (!loadedQuestions.doctor.length || !loadedQuestions.nurse.length) {
        console.error('Fehler: Keine Fragen wurden geladen. Überprüfen Sie die JSON-Datei und den URL-Pfad.');
        alert('Fehler beim Laden der Fragen. Bitte überprüfen Sie die Entwicklerkonsole für weitere Details.');
        return; // Beenden Sie das Spiel, wenn keine Fragen geladen wurden
      }

      document.getElementById('startScreen').style.display = 'none';
      init();
      animate();
      startTimer();
      spawnInitialPatient(); // Erster Patient spawnt beim Spielstart
      startContinuousPatientSpawning(); // Start des kontinuierlichen Patienten-Spawns
      startQuestionCheck(); // Start der Überprüfung der Fragen pro Minute
    }

    function init() {
      scene = new THREE.Scene();
      
      // Setze die Hintergrundfarbe der Szene auf blau
      scene.background = new THREE.Color(0x87CEEB); // Himmelblau
      
      // Kamera erstellen
      camera = new THREE.PerspectiveCamera(
        75, window.innerWidth / window.innerHeight, 0.1, 1000
      );

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Fokus auf das Renderer-Element setzen für Tastatursteuerung
      renderer.domElement.tabIndex = 1; // Macht das Element fokussierbar
      renderer.domElement.focus();

      // Beleuchtung
      var ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      var directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(100, 300, 100); // Position der Lichtquelle
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      // Boden hinzufügen
      createGround();

      // Krankenhaus erstellen
      createHospital();

      // Wegpunkte erstellen
      createWaypoints();

      // Spielerfigur erstellen
      createPlayer();

      // NPCs erstellen
      createNPCPool();
      selectRandomNPCs();

      // Kameraposition einstellen
      camera.position.set(0, 80, 150); // Noch näher heranzoomen

      camera.lookAt(new THREE.Vector3(0, 0, 0));

      // Steuerung initialisieren
      controls = {
        moveForward: false,
        moveBackward: false,
        moveLeft: false,
        moveRight: false
      };

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);

      gameStarted = true;
    }

    function createGround() {
      var groundGeometry = new THREE.PlaneGeometry(2000, 2000);
      var groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 }); // Grün für den Boden
      var ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2; // Ebene horizontal ausrichten
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);

      walls.push(ground); // Für Kollisionserkennung
    }

    function startTimer() {
      var timerElement = document.getElementById('timer');
      timerInterval = setInterval(function() {
        if (gameEnded) {
          clearInterval(timerInterval);
          return;
        }
        timer--;
        timerElement.innerText = timer;
        if (timer <= 0) {
          timer = 0;
          timerElement.innerText = timer;
          endGame(false);
        }
      }, 1000);
    }

    function createHospital() {
      var roomConfigs = [
        { x: -150, z: -150, width: 40, depth: 60, name: 'Notaufnahme', color: 0xffcccc },
        { x: 0, z: -150, width: 60, depth: 60, name: 'Wartezimmer', color: 0xccffcc },
        { x: 150, z: -150, width: 60, depth: 60, name: 'Radiologie', color: 0xccccff },
        { x: -150, z: 50, width: 60, depth: 60, name: 'Intensivstation', color: 0xffffcc },
        { x: 50, z: 50, width: 80, depth: 60, name: 'Allgemeine Station', color: 0xffccff },
        { x: 200, z: 50, width: 40, depth: 60, name: 'Operationssaal', color: 0xccffff },
        { x: -150, z: 250, width: 40, depth: 60, name: 'Apotheke', color: 0xffe4b5 },
        { x: 0, z: 250, width: 60, depth: 60, name: 'Labor', color: 0xd3d3d3 },
        { x: 150, z: 250, width: 60, depth: 60, name: 'Personalraum', color: 0xadd8e6 }
      ];

      roomConfigs.forEach(function(config) {
        createRoom(config);
      });

      // Wände für Kollisionserkennung sammeln
      walls = walls.concat(roomWalls);
    }

    function createRoom(config) {
      var wallThickness = 1;
      var wallHeight = 10;
      var wallsInRoom = [];

      var halfWidth = config.width / 2;
      var halfDepth = config.depth / 2;

      // Wandmaterial pro Raum
      var wallMaterial = new THREE.MeshLambertMaterial({ color: config.color });

      // Linke Wand
      var leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, config.depth), wallMaterial);
      leftWall.position.set(config.x - halfWidth, wallHeight / 2, config.z);
      scene.add(leftWall);
      wallsInRoom.push(leftWall);

      // Rechte Wand
      var rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, config.depth), wallMaterial);
      rightWall.position.set(config.x + halfWidth, wallHeight / 2, config.z);
      scene.add(rightWall);
      wallsInRoom.push(rightWall);

      // Hintere Wand
      var backWall = new THREE.Mesh(new THREE.BoxGeometry(config.width, wallHeight, wallThickness), wallMaterial);
      backWall.position.set(config.x, wallHeight / 2, config.z - halfDepth);
      scene.add(backWall);
      wallsInRoom.push(backWall);

      // Vordere Wand mit Tür
      var doorWidth = 8;
      var wall1Width = (config.width - doorWidth) / 2;

      var wall1 = new THREE.Mesh(new THREE.BoxGeometry(wall1Width, wallHeight, wallThickness), wallMaterial);
      wall1.position.set(config.x - wall1Width / 2 - doorWidth / 2, wallHeight / 2, config.z + halfDepth);
      scene.add(wall1);
      wallsInRoom.push(wall1);

      var wall2 = new THREE.Mesh(new THREE.BoxGeometry(wall1Width, wallHeight, wallThickness), wallMaterial);
      wall2.position.set(config.x + wall1Width / 2 + doorWidth / 2, wallHeight / 2, config.z + halfDepth);
      scene.add(wall2);
      wallsInRoom.push(wall2);

      // Tür
      var door = new THREE.Mesh(new THREE.BoxGeometry(doorWidth, wallHeight, 0.5), new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
      door.position.set(config.x, wallHeight / 2, config.z + halfDepth + 0.25);
      door.name = config.name;
      door.open = false;
      scene.add(door);
      doors.push(door);
      wallsInRoom.push(door); // Tür zur Kollisionserkennung hinzufügen

      // Türposition speichern
      var doorPosition = new THREE.Vector3(config.x, wallHeight / 2, config.z + halfDepth);

      // Türbeschriftung
      var loader = new THREE.FontLoader();
      loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
        var textGeometry = new THREE.TextGeometry(config.name, {
          font: font,
          size: 2,
          height: 0.5
        });
        var textMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
        var textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textMesh.position.set(config.x - config.name.length * 0.6, wallHeight + 2, config.z + halfDepth + 5);
        scene.add(textMesh);
      });

      // Raumgrenzen speichern
      var room = {
        name: config.name,
        minX: config.x - halfWidth,
        maxX: config.x + halfWidth,
        minZ: config.z - halfDepth,
        maxZ: config.z + halfDepth,
        doorPosition: doorPosition
      };
      rooms.push(room);

      // Wände für Kollisionserkennung sammeln
      wallsInRoom.forEach(function(wall) {
        roomWalls.push(wall);
      });

      // Möbel hinzufügen
      addFurnitureToRoom(room, wallHeight);
    }

    function addFurnitureToRoom(room, wallHeight) {
      // Pflanzen hinzufügen
      var plantGeometry = new THREE.CylinderGeometry(1, 1, 4, 16);
      var plantMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      var plant = new THREE.Mesh(plantGeometry, plantMaterial);
      plant.position.set(room.minX + 5, 2, room.minZ + 5);
      scene.add(plant);
      walls.push(plant); // Für Kollisionserkennung

      // Tisch hinzufügen
      var tableGeometry = new THREE.BoxGeometry(6, 1, 4);
      var tableMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
      var table = new THREE.Mesh(tableGeometry, tableMaterial);
      table.position.set(room.maxX - 6, 0.5, room.maxZ - 5);
      scene.add(table);
      walls.push(table);

      // Stuhl hinzufügen
      var chairGeometry = new THREE.BoxGeometry(2, 2, 2);
      var chairMaterial = new THREE.MeshLambertMaterial({ color: 0xA0522D });
      var chair = new THREE.Mesh(chairGeometry, chairMaterial);
      chair.position.set(room.maxX - 10, 1, room.maxZ - 5);
      scene.add(chair);
      walls.push(chair);

      // Bett hinzufügen
      var bedGeometry = new THREE.BoxGeometry(4, 1, 8);
      var bedMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
      var bed = new THREE.Mesh(bedGeometry, bedMaterial);
      bed.position.set(room.minX + 6, 0.5, room.maxZ - 5);
      scene.add(bed);
      walls.push(bed);
    }

    function createWaypoints() {
      // Begehbare Bereiche (Flure und offene Bereiche)
      waypoints = [
        // Flur vor den Räumen in der ersten Reihe
        new THREE.Vector3(-150, 1, -150),
        new THREE.Vector3(0, 1, -150),
        new THREE.Vector3(150, 1, -150),
        // Flur vor den Räumen in der zweiten Reihe
        new THREE.Vector3(-150, 1, 50),
        new THREE.Vector3(50, 1, 50),
        new THREE.Vector3(200, 1, 50),
        // Flur vor den Räumen in der dritten Reihe
        new THREE.Vector3(-150, 1, 250),
        new THREE.Vector3(0, 1, 250),
        new THREE.Vector3(150, 1, 250),
        // Kreuzungen
        new THREE.Vector3(-150, 1, 150),
        new THREE.Vector3(0, 1, 150),
        new THREE.Vector3(150, 1, 150),
        new THREE.Vector3(-150, 1, 200),
        new THREE.Vector3(0, 1, 200),
        new THREE.Vector3(150, 1, 200)
      ];
    }

    function createPlayer() {
      // Spielerfigur erstellen
      nurse = new THREE.Group();

      // Körper
      var bodyGeometry = new THREE.BoxGeometry(4, 8, 4);
      var bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 }); // Gelb
      var body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 4;
      nurse.add(body);

      // Kopf
      var headGeometry = new THREE.SphereGeometry(2, 16, 16);
      var headMaterial = new THREE.MeshLambertMaterial({ color: 0xffe0bd });
      var head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 8.75;
      nurse.add(head);

      // Arme
      var armGeometry = new THREE.BoxGeometry(1, 4, 1);
      var armMaterial = new THREE.MeshLambertMaterial({ color: 0xffe0bd });

      var leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-2.5, 3, 0);
      nurse.add(leftArm);
      nurse.leftArm = leftArm;

      var rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(2.5, 3, 0);
      nurse.add(rightArm);
      nurse.rightArm = rightArm;

      // Beine
      var legGeometry = new THREE.BoxGeometry(2, 4, 2);
      var legMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 }); // Gelb

      var leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-1, 0.5, 0);
      nurse.add(leftLeg);

      var rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(1, 0.5, 0);
      nurse.add(rightLeg);

      // Position der Spielerfigur auf der Bodenfläche
      nurse.position.set(0, 4, 0); // y = halbe Höhe des Körpers
      scene.add(nurse);
    }

    function createNPCPool() {
      // 50 NPCs mit detaillierten Geschichten generieren
      for (var i = 0; i < 50; i++) {
        var npcType = ['doctor', 'nurse', 'patient'][Math.floor(Math.random() * 3)];
        var npc = generateNPCData(npcType, i);
        npcPool.push(npc);
      }
    }

    function selectRandomNPCs() {
      // 10 zufällige NPCs auswählen
      currentNPCs = npcPool.sort(() => 0.5 - Math.random()).slice(0, 10);
      currentNPCs.forEach(function(data, index) {
        data.idNumber = index;
        createNPC(data.type, data);
      });
    }

    function generateNPCData(type, index) {
      var data = { idNumber: index, type: type };
      data.questions = [];

      data.name = '';
      data.story = '';

      switch (type) {
        case 'doctor':
          data.name = 'Dr. ' + ['Müller', 'Schmidt', 'Klein', 'Fischer', 'Weber'][index % 5];
          data.story = `Ich bin ${data.name}, ein Spezialist für ${['Kardiologie', 'Neurologie', 'Onkologie', 'Orthopädie', 'Dermatologie'][index % 5]}.`;
          break;
        case 'nurse':
          data.name = 'Pflegefachfrau ' + ['Diana', 'Bleona', 'Maria', 'Alina', 'Sophie'][index % 5];
          data.story = `Hallo, ich bin ${data.name}. Ich arbeite auf der Station für ${['Innere Medizin', 'Chirurgie', 'Pädiatrie', 'Gynäkologie', 'Psychiatrie'][index % 5]}.`;
          break;
        case 'patient':
          data.name = ['Thomas', 'Michael', 'Stefan', 'Andreas', 'Markus'][index % 5];
          data.story = `Hallo, ich bin ${data.name}. Ich bin Patient hier im Krankenhaus.`;
          break;
      }

      // Die Fragen werden nun aus der geladenen JSON-Datei genommen
      // Es wird angenommen, dass loadedQuestions bereits geladen wurde
      if (loadedQuestions[type] && loadedQuestions[type].length > 0) {
        // Shuffle the questions to ensure randomness
        var shuffled = loadedQuestions[type].sort(() => 0.5 - Math.random());
        // Nehmen Sie die ersten 10 Fragen oder weniger, je nach Verfügbarkeit
        data.questions = shuffled.slice(0, 10);
      }

      return data;
    }

    function createNPC(type, data) {
      var npc = new THREE.Group();

      // Körper
      var bodyGeometry = new THREE.BoxGeometry(4, 8, 4);
      var bodyMaterial;
      var symbol;
      switch(type) {
        case 'doctor':
          bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
          symbol = '⚕';
          break;
        case 'nurse':
          bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0000ff });
          symbol = '⛑';
          break;
        case 'patient':
          bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
          symbol = '☺';
          break;
        default:
          bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
          symbol = '?';
      }
      var body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 4;
      npc.add(body);

      // Kopf
      var headGeometry = new THREE.SphereGeometry(2, 16, 16);
      var headMaterial = new THREE.MeshLambertMaterial({ color: 0xffe0bd });
      var head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 8.75;
      npc.add(head);

      // Arme
      var armGeometry = new THREE.BoxGeometry(1, 4, 1);
      var armMaterial = new THREE.MeshLambertMaterial({ color: 0xffe0bd });

      var leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-2.5, 3, 0);
      npc.add(leftArm);
      npc.leftArm = leftArm;

      var rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(2.5, 3, 0);
      npc.add(rightArm);
      npc.rightArm = rightArm;

      // Beine
      var legGeometry = new THREE.BoxGeometry(2, 4, 2);
      var legMaterial = bodyMaterial;

      var leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-1, 0.5, 0);
      npc.add(leftLeg);

      var rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(1, 0.5, 0);
      npc.add(rightLeg);

      // Position setzen
      npc.position.copy(data.spawnPosition || new THREE.Vector3(0, 4, 0));

      npc.name = data.name;
      npc.story = data.story;
      npc.questions = data.questions;
      npc.idNumber = data.idNumber;
      npc.type = type;
      npc.targetPosition = null;
      npc.isPaused = false; // NPC ist standardmäßig nicht pausiert
      npc.questionsAsked = 0; // Anzahl der gestellten Fragen
      npc.cooldownActive = false; // Cooldown ist nicht aktiv
      npc.cooldownStartTime = 0; // Zeitpunkt des Cooldowns

      // Symbol über dem Kopf hinzufügen
      var spriteMaterial = new THREE.SpriteMaterial({
        map: new THREE.CanvasTexture(generateTextCanvas(symbol, 128)),
        transparent: true
      });
      var sprite = new THREE.Sprite(spriteMaterial);
      sprite.position.set(0, 10, 0);
      sprite.scale.set(10, 10, 1);
      npc.add(sprite);

      scene.add(npc);
      npcs.push(npc);
    }

    function generateTextCanvas(text, size) {
      var canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      var context = canvas.getContext('2d');
      context.font = size + 'px Arial';
      context.fillStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(text, size / 2, size / 2);
      return canvas;
    }

    function onKeyDown(event) {
      if (gameEnded) return;
      switch (event.keyCode) {
        case 87: // W
          controls.moveForward = true;
          break;
        case 83: // S
          controls.moveBackward = true;
          break;
        case 65: // A
          controls.moveLeft = true;
          break;
        case 68: // D
          controls.moveRight = true;
          break;
      }
    }

    function onKeyUp(event) {
      switch (event.keyCode) {
        case 87: // W
          controls.moveForward = false;
          break;
        case 83: // S
          controls.moveBackward = false;
          break;
        case 65: // A
          controls.moveLeft = false;
          break;
        case 68: // D
          controls.moveRight = false;
          break;
      }
    }

    function animate() {
      if (!gameStarted || gameEnded) return;

      requestAnimationFrame(animate);

      // Bewegung der Krankenschwester
      var speed = 1;
      var deltaX = 0;
      var deltaZ = 0;
      if (controls.moveForward) deltaZ -= speed;
      if (controls.moveBackward) deltaZ += speed;
      if (controls.moveLeft) deltaX -= speed;
      if (controls.moveRight) deltaX += speed;

      nurse.position.x += deltaX;
      nurse.position.z += deltaZ;

      // Kollisionserkennung für Spieler
      checkCollisions(nurse, deltaX, deltaZ);

      // Arme der Spielfigur bewegen
      animateArms(nurse, deltaX !== 0 || deltaZ !== 0);

      // Türen öffnen/schließen und Kollision aktualisieren
      updateDoors();

      // Kamera folgen
      camera.position.x = nurse.position.x;
      camera.position.z = nurse.position.z + 150; // Noch näher heranzoomen
      camera.position.y = 80; // Niedrigeres Y-Level für mehr Nähe
      camera.lookAt(nurse.position.x, nurse.position.y, nurse.position.z);

      // Wände transparent machen, wenn sie die Sicht blockieren
      updateTransparentWalls();

      // NPC-Bewegung
      npcs.forEach(function(npc) {
        if (npc.isPaused) {
          return; // NPC ist pausiert und bewegt sich nicht
        }

        // Wenn NPC kein Ziel hat, neues Ziel zuweisen
        if (!npc.targetPosition) {
          assignNPCTargetPosition(npc);
        }

        // Richtung zum Ziel berechnen
        var direction = new THREE.Vector3().subVectors(npc.targetPosition, npc.position);
        var distance = direction.length();

        if (distance > 5) { // Halten Sie einen Mindestabstand zum Ziel
          direction.normalize();
          var npcSpeed = 1;
          var deltaX_npc = direction.x * npcSpeed;
          var deltaZ_npc = direction.z * npcSpeed;

          npc.position.x += deltaX_npc;
          npc.position.z += deltaZ_npc;

          // Arme des NPCs bewegen
          animateArms(npc, true);

          // Kollisionserkennung für NPCs
          if (checkCollisions(npc, deltaX_npc, deltaZ_npc)) {
            // Bei Kollision neues Ziel zuweisen
            assignNPCTargetPosition(npc);
          }
        } else {
          // Ziel erreicht, neues Ziel zuweisen
          assignNPCTargetPosition(npc);

          // Arme des NPCs stoppen
          animateArms(npc, false);
        }
      });

      // Interaktion mit NPCs
      npcs.forEach(function(npc) {
        var distanceToNurse = nurse.position.distanceTo(npc.position);
        if (distanceToNurse < 10) { // Erhöht für größere Szene
          if (!questionActive && npc.type !== 'patient') {
            // Überprüfen, ob NPC sich im Cooldown befindet
            if (npc.cooldownActive) {
              var currentTime = Date.now();
              if (currentTime - npc.cooldownStartTime >= 60000) { // 1 Minute in ms
                // Cooldown beendet
                npc.cooldownActive = false;
                npc.questionsAsked = 0;
                showQuestion(npc);
              } else {
                // Cooldown noch aktiv
                var remainingTime = Math.ceil((60000 - (currentTime - npc.cooldownStartTime)) / 1000);
                showMessage(`${npc.name} kann bald wieder Fragen stellen. (${remainingTime} Sekunden verbleibend)`);
              }
            } else {
              showQuestion(npc);
            }
          }
        } else if (questionActive && currentNPC && currentNPC.idNumber === npc.idNumber && distanceToNurse >= 10) {
          hideQuestion();
        }

        // Behandlung von Patienteninteraktionen
        if (npc.type === 'patient' && distanceToNurse < 10 && !npc.isHealed) {
          healPatient(npc);
        }
      });

      renderer.render(scene, camera);
    }

    function animateArms(object, isMoving) {
      if (isMoving) {
        var time = Date.now() * 0.005;
        var armSwing = Math.sin(time) * 0.5;

        if (object.leftArm) {
          object.leftArm.rotation.x = armSwing;
        }
        if (object.rightArm) {
          object.rightArm.rotation.x = -armSwing;
        }
      } else {
        if (object.leftArm) {
          object.leftArm.rotation.x = 0;
        }
        if (object.rightArm) {
          object.rightArm.rotation.x = 0;
        }
      }
    }

    function checkCollisions(object, deltaX, deltaZ) {
      var collision = false;
      var objectBox = new THREE.Box3().setFromObject(object);
      walls.forEach(function(wall) {
        var wallBox = new THREE.Box3().setFromObject(wall);
        if (objectBox.intersectsBox(wallBox)) {
          object.position.x -= deltaX;
          object.position.z -= deltaZ;
          collision = true;
        }
      });
      return collision;
    }

    function updateDoors() {
      doors.forEach(function(door) {
        var nurseDistance = nurse.position.distanceTo(door.position);
        var npcNear = npcs.some(function(npc) {
          return npc.position.distanceTo(door.position) < 20; // Erhöht für größere Szene
        });

        if ((nurseDistance < 20 || npcNear) && !door.open) {
          door.open = true;
          // Tür aus Szene und Kollisionserkennung entfernen
          scene.remove(door);
          var index = walls.indexOf(door);
          if (index > -1) walls.splice(index, 1);
        } else if ((nurseDistance >= 20 && !npcNear) && door.open) {
          door.open = false;
          // Tür wieder zur Szene und Kollisionserkennung hinzufügen
          scene.add(door);
          walls.push(door);
        }
      });
    }

    function updateTransparentWalls() {
      transparentWalls.forEach(function(wall) {
        wall.material.opacity = 1;
        wall.material.transparent = false;
      });
      transparentWalls = [];

      var directionVector = nurse.position.clone().sub(camera.position).normalize();
      var raycaster = new THREE.Raycaster(camera.position, directionVector);
      var intersects = raycaster.intersectObjects(walls);

      intersects.forEach(function(intersect) {
        var wall = intersect.object;
        wall.material.opacity = 0.5;
        wall.material.transparent = true;
        transparentWalls.push(wall);
      });
    }

    function assignNPCTargetPosition(npc) {
      npc.targetPosition = waypoints[Math.floor(Math.random() * waypoints.length)].clone();
    }

    var currentNPC;

    function showQuestion(npc) {
      questionActive = true;
      currentNPC = npc;
      npc.isPaused = true; // NPC anhalten

      // Überprüfen, ob der NPC noch Fragen hat
      if (npc.questionsAsked >= 3) {
        // Starten Sie den Cooldown
        npc.cooldownActive = true;
        npc.cooldownStartTime = Date.now();
        showMessage(`${npc.name} benötigt eine Pause. Kann in 1 Minute wieder Fragen stellen.`);
        npc.isPaused = false;
        questionActive = false;
        currentNPC = null;
        return;
      }

      // Finde eine zufällige unbeantwortete Frage
      var npcKey = 'npc_' + npc.idNumber;
      if (!answeredQuestions[npcKey]) {
        answeredQuestions[npcKey] = [];
      }

      var remainingQuestions = npc.questions.filter((q, index) => !answeredQuestions[npcKey].includes(index));

      if (remainingQuestions.length === 0) {
        showMessage(`${npc.name}: "Vielen Dank für Ihre Hilfe!"`);
        npc.isPaused = false;
        questionActive = false;
        currentNPC = null;
        return;
      }

      var randomIndex = Math.floor(Math.random() * remainingQuestions.length);
      var questionData = remainingQuestions[randomIndex];
      var questionIndex = npc.questions.indexOf(questionData);

      questionDiv = document.createElement('div');
      questionDiv.id = 'question';
      questionDiv.innerHTML = `
        <p>${npc.story}</p>
        <p>${npc.name} fragt: ${questionData.question}</p>
        <button onclick="selectAnswer(1, ${npc.idNumber}, ${questionIndex})">${questionData.answers[0]}</button>
        <button onclick="selectAnswer(2, ${npc.idNumber}, ${questionIndex})">${questionData.answers[1]}</button>
        <button onclick="selectAnswer(3, ${npc.idNumber}, ${questionIndex})">${questionData.answers[2]}</button>
      `;
      document.body.appendChild(questionDiv);
    }

    function hideQuestion() {
      questionActive = false;
      if (questionDiv) {
        document.body.removeChild(questionDiv);
        questionDiv = null;
      }
      if (currentNPC) {
        currentNPC.isPaused = false; // NPC Bewegung fortsetzen
        currentNPC = null;
      }
    }

    function showMessage(text) {
      var messageDiv = document.getElementById('message');
      messageDiv.innerText = text;
      messageDiv.style.display = 'block';
      setTimeout(function() {
        messageDiv.style.display = 'none';
      }, 2000);
    }

    function selectAnswer(choice, npcId, questionIndex) {
      var npc = npcs.find(n => n.idNumber === npcId);
      var questionData = npc.questions[questionIndex];
      var message;
      if (choice === questionData.correctAnswer) {
        message = "Antwort ist richtig.";
        carePoints += 50; // Pflegepunkte erhöhen
        questionsAnsweredInLastMinute += 1; // Fragenüberprüfung aktualisieren
      } else {
        message = "Antwort ist leider falsch.";
        // Nur bei richtiger Antwort Punkte erhalten, keine Abzüge
      }
      showMessage(message);
      document.getElementById('carePoints').innerText = carePoints;

      // Frage als beantwortet markieren
      var npcKey = 'npc_' + npcId;
      if (!answeredQuestions[npcKey]) {
        answeredQuestions[npcKey] = [];
      }
      answeredQuestions[npcKey].push(questionIndex);
      npc.questionsAsked++;

      hideQuestion();

      // Überprüfen, ob der Spieler gewonnen hat (optional, kann angepasst werden)
      if (highscore >= 10) { // Beispiel: Spieler gewinnt bei 10 geheilten Patienten
        endGame(true);
      }
    }

    function endGame(won) {
      gameEnded = true;
      clearInterval(timerInterval);
      clearInterval(spawnIntervalId);
      clearInterval(questionCheckIntervalId);
      var endScreen = document.getElementById('endScreen');
      var endMessage = document.getElementById('endMessage');
      if (won) {
        endMessage.innerText = 'Sie haben gewonnen! Ihr Highscore: ' + highscore;
      } else {
        endMessage.innerText = 'Zeit abgelaufen oder Pflegepunkte aufgebraucht! Game Over. Ihr Highscore: ' + highscore;
      }
      endScreen.style.display = 'flex';
    }

    window.addEventListener('resize', function() {
      if (camera) { // Überprüfen, ob die Kamera definiert ist
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });

    // --- Neue Funktionen für Patientenmanagement ---

    // Funktion zum Spawn des ersten Patienten
    function spawnInitialPatient() {
      var position = getRandomGroundPosition();
      if (position) {
        markSpawnLocation(position);
        var patientData = generatePatientData();
        createPatient(patientData, position);
      }
    }

    // Funktion zum Markieren des Spawn-Ortes mit einem weißen 'H'
    function markSpawnLocation(position) {
      var spriteMaterial = new THREE.SpriteMaterial({
        map: new THREE.CanvasTexture(generateTextCanvas('H', 128)),
        transparent: true
      });
      var sprite = new THREE.Sprite(spriteMaterial);
      sprite.position.set(position.x, 5, position.z); // leicht über dem Boden
      sprite.scale.set(20, 20, 1);
      scene.add(sprite);
    }

    // Funktion zum Generieren von Patientendaten
    function generatePatientData() {
      var index = patients.length;
      var data = {
        idNumber: 'patient_' + index,
        type: 'patient',
        name: 'Patient ' + (index + 1),
        story: 'Hallo, ich bin Patient ' + (index + 1) + '.'
      };
      return data;
    }

    // Funktion zum Erstellen eines Patienten
    function createPatient(data, position) {
      var npc = new THREE.Group();

      // Körper
      var bodyGeometry = new THREE.BoxGeometry(4, 8, 4);
      var bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
      var body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 4;
      npc.add(body);

      // Kopf
      var headGeometry = new THREE.SphereGeometry(2, 16, 16);
      var headMaterial = new THREE.MeshLambertMaterial({ color: 0xffe0bd });
      var head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 8.75;
      npc.add(head);

      // Arme
      var armGeometry = new THREE.BoxGeometry(1, 4, 1);
      var armMaterial = new THREE.MeshLambertMaterial({ color: 0xffe0bd });

      var leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-2.5, 3, 0);
      npc.add(leftArm);
      npc.leftArm = leftArm;

      var rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(2.5, 3, 0);
      npc.add(rightArm);
      npc.rightArm = rightArm;

      // Beine
      var legGeometry = new THREE.BoxGeometry(2, 4, 2);
      var legMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });

      var leftLeg = new THREE.Mesh(legGeometry, legMaterial);
      leftLeg.position.set(-1, 0.5, 0);
      npc.add(leftLeg);

      var rightLeg = new THREE.Mesh(legGeometry, legMaterial);
      rightLeg.position.set(1, 0.5, 0);
      npc.add(rightLeg);

      // Position setzen
      npc.position.copy(position);
      npc.position.y = 4; // y = Bodenhöhe + halbe Höhe des Körpers

      npc.name = data.name;
      npc.story = data.story;
      npc.type = data.type;
      npc.targetPosition = null;
      npc.isPaused = false; // NPC ist standardmäßig nicht pausiert
      npc.questionsAsked = 0; // Anzahl der gestellten Fragen
      npc.cooldownActive = false; // Cooldown ist nicht aktiv
      npc.cooldownStartTime = 0; // Zeitpunkt des Cooldowns
      npc.isHealed = false; // Flag für geheilten Patienten

      // Symbol über dem Kopf hinzufügen
      var spriteMaterial = new THREE.SpriteMaterial({
        map: new THREE.CanvasTexture(generateTextCanvas('P', 128)),
        transparent: true
      });
      var sprite = new THREE.Sprite(spriteMaterial);
      sprite.position.set(0, 10, 0);
      sprite.scale.set(10, 10, 1);
      npc.add(sprite);

      scene.add(npc);
      patients.push(npc);
      npcs.push(npc); // Patienten sind auch Teil der NPC-Liste
    }

    // Funktion zum Generieren einer zufälligen Position auf dem Boden außerhalb der Gebäude
    function getRandomGroundPosition() {
      var maxAttempts = 100;
      for (var i = 0; i < maxAttempts; i++) {
        var x = (Math.random() - 0.5) * 2000; // Boden ist 2000x2000
        var z = (Math.random() - 0.5) * 2000;
        if (isPositionValid(x, z)) {
          return new THREE.Vector3(x, 0, z);
        }
      }
      console.warn('Keine gültige Position für den Patienten gefunden.');
      return null;
    }

    // Funktion zur Überprüfung, ob eine Position außerhalb aller Gebäude liegt
    function isPositionValid(x, z) {
      for (var i = 0; i < rooms.length; i++) {
        var room = rooms[i];
        if (x > room.minX && x < room.maxX && z > room.minZ && z < room.maxZ) {
          return false; // Position liegt innerhalb eines Gebäudes
        }
      }
      return true; // Position liegt außerhalb aller Gebäude
    }

    // Funktion zum Starten des kontinuierlichen Patienten-Spawns
    function startContinuousPatientSpawning() {
      spawnIntervalId = setInterval(function() {
        spawnPatient();
        // Optionale Anpassung der Spawnrate im Verlauf des Spiels
        // Zum Beispiel alle 2 Minuten die Spawnrate leicht erhöhen
        if (timer % 120 === 0 && timer > 0) {
          adjustSpawnRate();
        }
      }, patientSpawnInterval);
    }

    // Funktion zum Anpassen der Spawnrate basierend auf der Spielerleistung
    function adjustSpawnRate() {
      if (questionsAnsweredInLastMinute < 1) {
        // Spieler hat keine Fragen beantwortet, erhöhe die Spawnrate aggressiver
        patientSpawnInterval = Math.max(2000, patientSpawnInterval - 1000); // Reduziere um 1 Sekunde, Mindestintervall 2 Sekunden
        clearInterval(spawnIntervalId);
        spawnIntervalId = setInterval(spawnPatient, patientSpawnInterval);
        showMessage("Sie haben keine Fragen beantwortet! Patienten spawnen jetzt schneller.");
      } else {
        // Spieler hat Fragen beantwortet, erhöhe die Spawnrate leicht
        patientSpawnInterval = Math.max(3000, patientSpawnInterval - 500); // Reduziere um 0,5 Sekunden, Mindestintervall 3 Sekunden
        clearInterval(spawnIntervalId);
        spawnIntervalId = setInterval(spawnPatient, patientSpawnInterval);
        showMessage("Gute Arbeit! Patienten spawnen leicht schneller.");
      }
      // Reset der Zählung für die nächste Minute
      questionsAnsweredInLastMinute = 0;
    }

    // Funktion zur Überprüfung, ob der Spieler genügend Fragen beantwortet hat
    function startQuestionCheck() {
      questionCheckIntervalId = setInterval(function() {
        // Überprüfen, ob der Spieler mindestens eine Frage in der letzten Minute beantwortet hat
        if (questionsAnsweredInLastMinute < 1) {
          // Spieler hat keine Fragen beantwortet, erhöhe die Spawnrate aggressiver
          patientSpawnInterval = Math.max(2000, patientSpawnInterval - 1000); // Minimum 2 Sekunden
          clearInterval(spawnIntervalId);
          spawnIntervalId = setInterval(spawnPatient, patientSpawnInterval);
          showMessage("Sie haben keine Fragen beantwortet! Patienten spawnen jetzt schneller.");
        } else {
          // Spieler hat Fragen beantwortet, halte die Spawnrate oder erhöhe sie leicht
          patientSpawnInterval = Math.max(3000, patientSpawnInterval - 500); // Minimum 3 Sekunden
          clearInterval(spawnIntervalId);
          spawnIntervalId = setInterval(spawnPatient, patientSpawnInterval);
          showMessage("Gute Arbeit! Patienten spawnen leicht schneller.");
        }
        // Reset der Zählung für die nächste Minute
        questionsAnsweredInLastMinute = 0;
      }, questionCheckInterval);
    }

    // Funktion zur Heilung eines Patienten
    function healPatient(patient) {
      patient.isHealed = true;
      patient.isPaused = true;

      // Kurze, freudige Animation (z.B. Skalierung)
      var duration = 500; // Dauer der Animation in ms
      var startTime = Date.now();
      var initialScale = patient.scale.clone();
      var targetScale = new THREE.Vector3(2, 2, 2); // Vergrößerung für die Animation

      function animateHealing() {
        var elapsed = Date.now() - startTime;
        var progress = elapsed / duration;
        if (progress < 1) {
          patient.scale.lerpVectors(initialScale, targetScale, progress);
          requestAnimationFrame(animateHealing);
        } else {
          // Animation abgeschlossen, Patient entfernen
          scene.remove(patient);
          var index = npcs.indexOf(patient);
          if (index > -1) npcs.splice(index, 1);
          var pIndex = patients.indexOf(patient);
          if (pIndex > -1) patients.splice(pIndex, 1);

          // Pflegepunkte abziehen
          carePoints -= 5;
          if (carePoints < 0) carePoints = 0;
          document.getElementById('carePoints').innerText = carePoints;

          // Highscore erhöhen
          highscore += 1;
          document.getElementById('highscore').innerText = highscore;

          showMessage("Patient geheilt! Pflegepunkte abgezogen.");

          // Überprüfen, ob der Spieler verloren hat (optional)
          if (carePoints <= 0) {
            endGame(false);
          }
        }
      }

      animateHealing();
    }

    // Funktion zur Heilung eines Patienten
    function spawnPatient() {
      var position = getRandomGroundPosition();
      if (position) {
        createPatient(generatePatientData(), position);
      }
    }

    // --- Ende der neuen Funktionen für Patientenmanagement ---

    // Hinweis: Der ursprüngliche animate() Loop wurde bereits oben überschrieben.
    
  </script>
</body>
</html>
